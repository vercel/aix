///
/// HybridAixComponent.mm
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2026 Marc Rousavy @ Margelo
///

#import "HybridAixComponent.hpp"
#import <memory>
#import <react/renderer/componentregistry/ComponentDescriptorProvider.h>
#import <React/RCTViewComponentView.h>
#import <React/RCTComponentViewFactory.h>
#import <React/UIView+ComponentViewProtocol.h>
#import <NitroModules/NitroDefines.hpp>
#import <UIKit/UIKit.h>

#import "HybridAixSpecSwift.hpp"
#import "Aix-Swift-Cxx-Umbrella.hpp"

using namespace facebook;
using namespace margelo::nitro::aix;
using namespace margelo::nitro::aix::views;

/**
 * Represents the React Native View holder for the Nitro "Aix" HybridView.
 */
@interface HybridAixComponent: RCTViewComponentView
@end

@implementation HybridAixComponent {
  std::shared_ptr<HybridAixSpecSwift> _hybridView;
}

+ (void) load {
  [super load];
  [RCTComponentViewFactory.currentComponentViewFactory registerComponentViewClass:[HybridAixComponent class]];
}

+ (react::ComponentDescriptorProvider) componentDescriptorProvider {
  return react::concreteComponentDescriptorProvider<HybridAixComponentDescriptor>();
}

- (instancetype) init {
  if (self = [super init]) {
    std::shared_ptr<HybridAixSpec> hybridView = Aix::AixAutolinking::createAix();
    _hybridView = std::dynamic_pointer_cast<HybridAixSpecSwift>(hybridView);
    [self updateView];
  }
  return self;
}

- (void) updateView {
  // 1. Get Swift part
  Aix::HybridAixSpec_cxx& swiftPart = _hybridView->getSwiftPart();

  // 2. Get UIView*
  void* viewUnsafe = swiftPart.getView();
  UIView* view = (__bridge_transfer UIView*) viewUnsafe;

  // 3. Update RCTViewComponentView's [contentView]
  [self setContentView:view];
}

- (void) updateProps:(const std::shared_ptr<const react::Props>&)props
            oldProps:(const std::shared_ptr<const react::Props>&)oldProps {
  // 1. Downcast props
  const auto& newViewPropsConst = *std::static_pointer_cast<HybridAixProps const>(props);
  auto& newViewProps = const_cast<HybridAixProps&>(newViewPropsConst);
  Aix::HybridAixSpec_cxx& swiftPart = _hybridView->getSwiftPart();

  // 2. Update each prop individually
  swiftPart.beforeUpdate();

  // shouldStartAtEnd: boolean
  if (newViewProps.shouldStartAtEnd.isDirty) {
    swiftPart.setShouldStartAtEnd(newViewProps.shouldStartAtEnd.value);
    newViewProps.shouldStartAtEnd.isDirty = false;
  }
  // scrollOnFooterSizeUpdate: optional
  if (newViewProps.scrollOnFooterSizeUpdate.isDirty) {
    swiftPart.setScrollOnFooterSizeUpdate(newViewProps.scrollOnFooterSizeUpdate.value);
    newViewProps.scrollOnFooterSizeUpdate.isDirty = false;
  }
  // scrollEndReachedThreshold: optional
  if (newViewProps.scrollEndReachedThreshold.isDirty) {
    swiftPart.setScrollEndReachedThreshold(newViewProps.scrollEndReachedThreshold.value);
    newViewProps.scrollEndReachedThreshold.isDirty = false;
  }
  // additionalContentInsets: optional
  if (newViewProps.additionalContentInsets.isDirty) {
    swiftPart.setAdditionalContentInsets(newViewProps.additionalContentInsets.value);
    newViewProps.additionalContentInsets.isDirty = false;
  }
  // additionalScrollIndicatorInsets: optional
  if (newViewProps.additionalScrollIndicatorInsets.isDirty) {
    swiftPart.setAdditionalScrollIndicatorInsets(newViewProps.additionalScrollIndicatorInsets.value);
    newViewProps.additionalScrollIndicatorInsets.isDirty = false;
  }
  // mainScrollViewID: optional
  if (newViewProps.mainScrollViewID.isDirty) {
    swiftPart.setMainScrollViewID(newViewProps.mainScrollViewID.value);
    newViewProps.mainScrollViewID.isDirty = false;
  }
  // penultimateCellIndex: optional
  if (newViewProps.penultimateCellIndex.isDirty) {
    swiftPart.setPenultimateCellIndex(newViewProps.penultimateCellIndex.value);
    newViewProps.penultimateCellIndex.isDirty = false;
  }
  // shouldApplyContentInsets: optional
  if (newViewProps.shouldApplyContentInsets.isDirty) {
    swiftPart.setShouldApplyContentInsets(newViewProps.shouldApplyContentInsets.value);
    newViewProps.shouldApplyContentInsets.isDirty = false;
  }
  // applyContentInsetDelay: optional
  if (newViewProps.applyContentInsetDelay.isDirty) {
    swiftPart.setApplyContentInsetDelay(newViewProps.applyContentInsetDelay.value);
    newViewProps.applyContentInsetDelay.isDirty = false;
  }
  // onWillApplyContentInsets: optional
  if (newViewProps.onWillApplyContentInsets.isDirty) {
    swiftPart.setOnWillApplyContentInsets(newViewProps.onWillApplyContentInsets.value);
    newViewProps.onWillApplyContentInsets.isDirty = false;
  }
  // onScrolledNearEndChange: optional
  if (newViewProps.onScrolledNearEndChange.isDirty) {
    swiftPart.setOnScrolledNearEndChange(newViewProps.onScrolledNearEndChange.value);
    newViewProps.onScrolledNearEndChange.isDirty = false;
  }
  // scrollToIndex: optional
  if (newViewProps.scrollToIndex.isDirty) {
    swiftPart.setScrollToIndex(newViewProps.scrollToIndex.value);
    newViewProps.scrollToIndex.isDirty = false;
  }
  // onDidScrollToIndex: optional
  if (newViewProps.onDidScrollToIndex.isDirty) {
    swiftPart.setOnDidScrollToIndex(newViewProps.onDidScrollToIndex.value);
    newViewProps.onDidScrollToIndex.isDirty = false;
  }

  swiftPart.afterUpdate();

  // 3. Update hybridRef if it changed
  if (newViewProps.hybridRef.isDirty) {
    // hybridRef changed - call it with new this
    const auto& maybeFunc = newViewProps.hybridRef.value;
    if (maybeFunc.has_value()) {
      maybeFunc.value()(_hybridView);
    }
    newViewProps.hybridRef.isDirty = false;
  }

  // 4. Continue in base class
  [super updateProps:props oldProps:oldProps];
}

@end
